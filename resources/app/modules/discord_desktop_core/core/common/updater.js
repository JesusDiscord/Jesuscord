"use strict";const childProcess=require("child_process"),{app:app}=require("electron"),{EventEmitter:EventEmitter}=require("events"),NodeModule=require("module"),path=require("path"),{hrtime:hrtime}=require("process");let instance;const TASK_STATE_COMPLETE="Complete",TASK_STATE_FAILED="Failed",TASK_STATE_WAITING="Waiting",TASK_STATE_WORKING="Working";class Updater extends EventEmitter{constructor(e){super();let t=e.nativeUpdaterModule;if(null==t)try{t=require("../../../updater")}catch(e){if("MODULE_NOT_FOUND"===e.code)return;throw e}this.committedHostVersion=null,this.committedModules=new Set,this.rootPath=e.root_path,this.nextRequestId=0,this.requests=new Map,this.updateEventHistory=[],this.isRunningInBackground=!1,this.currentlyDownloading={},this.currentlyInstalling={},this.hasEmittedUnhandledException=!1,this.nativeUpdater=new t.Updater({response_handler:this._handleResponse.bind(this),...e})}get valid(){return null!=this.nativeUpdater}_sendRequest(e,t=null){if(!this.valid)throw new Error("Can't send request to updater because the native updater isn't loaded.");const s=this.nextRequestId++;return new Promise((n,r)=>{this.requests.set(s,{resolve:n,reject:r,progressCallback:t}),this.nativeUpdater.command(JSON.stringify([s,e]))})}_sendRequestSync(e){if(!this.valid)throw new Error("Can't send request to updater because the native updater isn't loaded.");const t=this.nextRequestId++;return this.nativeUpdater.command_blocking(JSON.stringify([t,e]))}_handleResponse(e){try{const[t,s]=JSON.parse(e),n=this.requests.get(t);if(null==n)return void console.error("Received response ",s," for a request (",t,") not in the updater request map.");if(null!=s.Error)n.reject(new Error(s.Error)),this.requests.delete(t);else if("Ok"===s)n.resolve(),this.requests.delete(t);else if(null!=s.VersionInfo)n.resolve(s.VersionInfo),this.requests.delete(t);else if(null!=s.ManifestInfo)n.resolve(s.ManifestInfo),this.requests.delete(t);else if(null!=s.TaskProgress){const e=s.TaskProgress,t={task:e[0],state:e[1],percent:e[2],bytesProcessed:e[3]};this._recordTaskProgress(t),null!=n.progressCallback&&n.progressCallback(t),null!=t.task.HostInstall&&"Complete"===t.state&&this.emit("host-updated")}else console.warn("Unknown updater response",s)}catch(e){console.error("Unhandled exception in updater response handler:",e),this.hasEmittedUnhandledException||(this.hasEmittedUnhandledException=!0,this.emit("unhandled-exception",e))}}_handleSyncResponse(e){const t=JSON.parse(e);if(null!=t.Error)throw new Error(t.Error);if("Ok"!==t)return null!=t.VersionInfo?t.VersionInfo:void console.warn("Unknown updater response",t)}_getHostPath(){const[e,t,s]=this.committedHostVersion,n=`${e}.${t}.${s}`;return path.join(this.rootPath,"app-"+n)}_startCurrentVersionInner(e,t){null==this.committedHostVersion&&(this.committedHostVersion=t.current_host);const s=this._getHostPath(),n=path.join(s,path.basename(process.execPath));if(path.resolve(n)!=path.resolve(process.execPath)&&!(null==e?void 0:e.allowObsoleteHost))return app.once("will-quit",()=>{childProcess.spawn(n,[],{detached:!0,stdio:"inherit"})}),console.log(`Restarting from ${path.resolve(process.execPath)} to ${path.resolve(n)}`),void app.quit();this._commitModulesInner(t)}_commitModulesInner(e){const t=this._getHostPath(),s=path.join(t,"modules");for(const t in e.current_modules){const n=e.current_modules[t],r=path.join(s,`${t}-${n}`);this.committedModules.has(t)||-1!==NodeModule.globalPaths.indexOf(r)||(this.committedModules.add(t),NodeModule.globalPaths.push(r))}}_recordDownloadProgress(e,t){const s=String(hrtime.bigint());"Working"!==t.state||this.currentlyDownloading[e]?"Complete"!==t.state&&"Failed"!==t.state||(this.currentlyDownloading[e]=!1,this.updateEventHistory.push({type:"downloaded-module",name:e,now:s,succeeded:"Complete"===t.state,receivedBytes:t.bytesProcessed})):(this.currentlyDownloading[e]=!0,this.updateEventHistory.push({type:"downloading-module",name:e,now:s}))}_recordInstallProgress(e,t,s,n){const r=String(hrtime.bigint());"Working"!==t.state||this.currentlyInstalling[e]?"Complete"!==t.state&&"Failed"!==t.state||(this.currentlyInstalling[e]=!1,this.updateEventHistory.push({type:"installed-module",name:e,now:r,newVersion:s,succeeded:"Complete"===t.state,delta:n,foreground:!this.isRunningInBackground})):(this.currentlyInstalling[e]=!0,this.updateEventHistory.push({type:"installing-module",name:e,now:r,newVersion:s,foreground:!this.isRunningInBackground}))}_recordTaskProgress(e){null!=e.task.HostDownload?this._recordDownloadProgress("host",e):null!=e.task.HostInstall?this._recordInstallProgress("host",e,null,null!=e.task.HostInstall.from_version):null!=e.task.ModuleDownload?this._recordDownloadProgress(e.task.ModuleDownload.version.module.name,e):null!=e.task.ModuleInstall&&this._recordInstallProgress(e.task.ModuleInstall.version.module.name,e,e.task.ModuleInstall.version.version,null!=e.task.ModuleInstall.from_version)}queryCurrentVersions(){return this._sendRequest("QueryCurrentVersions")}queryCurrentVersionsSync(){return this._handleSyncResponse(this._sendRequestSync("QueryCurrentVersions"))}repair(e){return this._sendRequest("Repair",e)}collectGarbage(){return this._sendRequest("CollectGarbage")}setRunningManifest(e){return this._sendRequest({SetManifests:["Running",e]})}setPinnedManifestSync(e){return this._handleSyncResponse(this._sendRequestSync({SetManifests:["Pinned",e]}))}installModule(e,t){return this._sendRequest({InstallModule:e},t)}updateToLatest(e){return this._sendRequest("UpdateToLatest",e)}async startCurrentVersion(e){const t=await this.queryCurrentVersions();await this.setRunningManifest(t.last_successful_update),this._startCurrentVersionInner(e,t)}startCurrentVersionSync(e){const t=this.queryCurrentVersionsSync();this._startCurrentVersionInner(e,t)}async commitModules(e){if(null==this.committedHostVersion)throw new Error("Cannot commit modules before host version.");null==e&&(e=await this.queryCurrentVersions()),this._commitModulesInner(e)}setRunningInBackground(){this.isRunningInBackground=!0}queryAndTruncateHistory(){const e=this.updateEventHistory;return this.updateEventHistory=[],e}}function getUpdaterPlatformName(e){switch(e){case"darwin":return"osx";case"win32":return"win";default:return e}}function tryInitUpdater(e,t){const s=require("./paths").getInstallPath();return null!=s&&(instance=new Updater({release_channel:e.releaseChannel,platform:getUpdaterPlatformName(process.platform),repository_url:t,root_path:s}),instance.valid)}function getUpdater(){if(null!=instance&&instance.valid)return instance}module.exports={Updater:Updater,tryInitUpdater:tryInitUpdater,getUpdater:getUpdater,TASK_STATE_COMPLETE:"Complete",TASK_STATE_FAILED:"Failed",TASK_STATE_WAITING:"Waiting",TASK_STATE_WORKING:"Working"};