"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getMainWindowId = getMainWindowId, exports.webContentsSend = webContentsSend, exports.init = init, exports.handleOpenUrl = handleOpenUrl, exports.setMainWindowVisible = setMainWindowVisible, exports.setBlurType = setBlurType, exports.setVibrancy = setVibrancy; const events = exports.events = new (require("events").EventEmitter), VIBRANCY_TYPES = ["titlebar", "selection", "menu", "popover", "sidebar", "header", "sheet", "window", "hud", "fullscreen-ui", "tooltip", "content", "under-window", "under-page", "none"], BLUR_TYPES = ["blurbehind", "acrylic", "transparent"]; var glasstron = require("glasstron"), _electron = require("electron"), _fs = _interopRequireDefault(require("fs")), _path = _interopRequireDefault(require("path")), _url = _interopRequireDefault(require("url")), _Backoff = _interopRequireDefault(require("../common/Backoff")), _securityUtils = require("../common/securityUtils"), appBadge = _interopRequireWildcard(require("./appBadge")), appConfig = _interopRequireWildcard(require("./appConfig")), _appSettings = require("./appSettings"), _buildInfo = _interopRequireDefault(require("./buildInfo")), _ipcMain = _interopRequireDefault(require("./ipcMain")), legacyModuleUpdater = _interopRequireWildcard(require("./moduleUpdater")), _updater = _interopRequireDefault(require("./updater")), notificationScreen = _interopRequireWildcard(require("./notificationScreen")), paths = _interopRequireWildcard(require("./paths")), popoutWindows = _interopRequireWildcard(require("./popoutWindows")), splashScreen = _interopRequireWildcard(require("./splashScreen")), systemTray = _interopRequireWildcard(require("./systemTray")), _Constants = require("./Constants"); function _getRequireWildcardCache() { if ("function" != typeof WeakMap) return null; var e = new WeakMap; return _getRequireWildcardCache = function () { return e }, e } function _interopRequireWildcard(e) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var n = _getRequireWildcardCache(); if (n && n.has(e)) return n.get(e); var t = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o)) { var a = i ? Object.getOwnPropertyDescriptor(e, o) : null; a && (a.get || a.set) ? Object.defineProperty(t, o, a) : t[o] = e[o] } return t.default = e, n && n.set(e, t), t } function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const settings = (0, _appSettings.getSettings)(), connectionBackoff = new _Backoff.default(1e3, 2e4), DISCORD_NAMESPACE = "DISCORD_"; let isTabs = !1; const getWebappEndpoint = () => { if (isTabs = settings.get("isTabs", !1)) return "file://" + _path.default.join(__dirname, "tabs", "index.html"); { let e = settings.get("WEBAPP_ENDPOINT"); return e || (e = "stable" === _buildInfo.default.releaseChannel ? "https://discord.com" : "development" === _buildInfo.default.releaseChannel ? "https://canary.discord.com" : `https://${_buildInfo.default.releaseChannel}.discord.com`), e } }, WEBAPP_ENDPOINT = getWebappEndpoint(); function checkUrlOriginMatches(e, n) { let t, i; try { t = _url.default.parse(e), i = _url.default.parse(n) } catch (e) { return !1 } return t.protocol === i.protocol && t.slashes === i.slashes && t.host === i.host } function getSanitizedPath(e) { return new _url.default.URL(e, WEBAPP_ENDPOINT).pathname } function getSanitizedProtocolPath(e) { try { const n = _url.default.parse(e); if ("Justicecord:" === n.protocol) return getSanitizedPath(n.path) } catch (e) { } return null } const WEBAPP_PATH = settings.get("WEBAPP_PATH", "/app?_=" + Date.now()); let URL_TO_LOAD = `${WEBAPP_ENDPOINT}${WEBAPP_PATH}`; WEBAPP_ENDPOINT.startsWith("file://") && (URL_TO_LOAD = `${WEBAPP_ENDPOINT}?path=${encodeURIComponent(WEBAPP_PATH)}`); const MIN_WIDTH = settings.get("MIN_WIDTH", 940), MIN_HEIGHT = settings.get("MIN_HEIGHT", 500), DEFAULT_WIDTH = 1280, DEFAULT_HEIGHT = 720, MIN_VISIBLE_ON_SCREEN = 32; let mainWindow = null, mainWindowId = _Constants.DEFAULT_MAIN_WINDOW_ID, mainWindowInitialPath = null, mainWindowDidFinishLoad = !1, insideAuthFlow = !1, lastCrashed = 0, lastPageLoadFailed = !1; function getMainWindowId() { return mainWindowId } function webContentsSend(...e) { if (null != mainWindow && null != mainWindow.webContents) { const [n, ...t] = e; mainWindow.webContents.send("DISCORD_" + n, ...t) } } function saveWindowConfig(e) { try { if (!e) return; if (settings.get("NO_WINDOWS_BOUND")) return; settings.set("IS_MAXIMIZED", e.isMaximized()), settings.set("IS_MINIMIZED", e.isMinimized()), settings.get("IS_MAXIMIZED") || settings.get("IS_MINIMIZED") || settings.set("WINDOW_BOUNDS", e.getBounds()), settings.save() } catch (e) { console.error(e) } } function setBlur(e) { if (mainWindow) { if ("boolean" != typeof e) throw new TypeError("INVALID ARGUMENT: blur"); mainWindow.setBlur(e) } } function setVibrancy(e) { if (mainWindow) { if (!VIBRANCY_TYPES.includes(e)) throw new TypeError("INVALID ARGUMENT: vibrancy"); mainWindow.setVibrancy(e), settings.set("GLASSTRON_VIBRANCY", e) } } function setBlurType(e) { if (mainWindow) { if (!BLUR_TYPES.includes(e)) throw new TypeError("INVALID ARGUMENT: blurType"); mainWindow.blurType = e, settings.set("GLASSTRON_BLUR", e) } } function setDefaultBlur() { if (!mainWindow) return; let e = settings.get("GLASSTRON_BLUR", "blurbehind"); BLUR_TYPES.includes(e) || (e = "blurbehind", settings.set("GLASSTRON_BLUR", e)), setBlurType(e); let n = settings.get("GLASSTRON_VIBRANCY", "fullscreen-ui"); VIBRANCY_TYPES.includes(n) || (n = "fullscreen-ui", settings.set("GLASSTRON_VIBRANCY", n)), setVibrancy(n), setBlur(!0) } function setWindowVisible(e, n) { null != mainWindow && (e ? !n && mainWindow.isMinimized() || (mainWindow.show(), webContentsSend("MAIN_WINDOW_FOCUS")) : (webContentsSend("MAIN_WINDOW_BLUR"), mainWindow.hide(), systemTray.hasInit && systemTray.displayHowToCloseHint()), mainWindow.setSkipTaskbar(!e)) } function doAABBsOverlap(e, n) { const t = e.x + e.width, i = n.x + n.width, o = e.y + e.height, a = n.y + n.height; return (t < i ? t : i) - (e.x < n.x ? n.x : e.x) > 0 && (o < a ? o : a) - (e.y < n.y ? n.y : e.y) > 0 } function applyWindowBoundsToConfig(e) { if (!settings.get("WINDOW_BOUNDS")) return void (e.center = !0); const n = settings.get("WINDOW_BOUNDS"); n.width = Math.max(MIN_WIDTH, n.width), n.height = Math.max(MIN_HEIGHT, n.height); let t = !1; _electron.screen.getAllDisplays().forEach(e => { if (t) return; const i = e.workArea; i.x += 32, i.y += 32, i.width -= 64, i.height -= 64, t = doAABBsOverlap(n, i) }), t ? (e.width = n.width, e.height = n.height, e.x = n.x, e.y = n.y) : e.center = !0 } function setupNotificationScreen(e) { notificationScreen.hasInit ? notificationScreen.setMainWindow(e) : (notificationScreen.init({ mainWindow: e, title: "Justicecord Notifications", maxVisible: 5, screenPosition: "bottom" }), notificationScreen.events.on(notificationScreen.NOTIFICATION_CLICK, () => { setWindowVisible(!0, !0) })) } function setupSystemTray() { systemTray.hasInit || systemTray.init({ onCheckForUpdates: () => { const e = null === _updater.default || void 0 === _updater.default ? void 0 : _updater.default.getUpdater(); null != e ? checkForUpdatesWithUpdater(e) : legacyModuleUpdater.checkForUpdates() }, onTrayClicked: () => setWindowVisible(!0, !0), onOpenVoiceSettings: openVoiceSettings, onToggleMute: toggleMute, onToggleDeafen: toggleDeafen, onLaunchApplication: launchApplication }) } function setupAppBadge() { appBadge.hasInit || appBadge.init() } function setupAppConfig() { appConfig.hasInit || appConfig.init() } function setupPopouts() { popoutWindows.hasInit || popoutWindows.init() } function openVoiceSettings() { setWindowVisible(!0, !0), webContentsSend("SYSTEM_TRAY_OPEN_VOICE_SETTINGS") } function toggleMute() { webContentsSend("SYSTEM_TRAY_TOGGLE_MUTE") } function toggleDeafen() { webContentsSend("SYSTEM_TRAY_TOGGLE_DEAFEN") } function launchApplication(e) { webContentsSend("LAUNCH_APPLICATION", e) } const loadMainPage = () => { lastPageLoadFailed = !1, mainWindow.loadURL(URL_TO_LOAD) }, DEFAULT_BACKGROUND_COLOR = "#2f3136", BACKGROUND_COLOR_KEY = "BACKGROUND_COLOR"; function getBackgroundColor() { return settings.get("BACKGROUND_COLOR", "#2f3136") } function setBackgroundColor(e) { settings.set("BACKGROUND_COLOR", e), settings.save() } function launchMainAppWindow(e) { mainWindow && mainWindow.destroy(); const n = { title: "Justicecord", width: 1280, height: 720, minWidth: MIN_WIDTH, minHeight: MIN_HEIGHT, transparent: !1, frame: !1, resizable: !0, show: e, webPreferences: { blinkFeatures: "EnumerateDevices,AudioOutputDevices", nativeWindowOpen: !0, enableRemoteModule: !0, spellcheck: !0, contextIsolation: !1, ...isTabs ? { nodeIntegration: !0, webviewTag: !0 } : { nodeIntegration: !1, webviewTag: !1, contextIsolation: !1, preload: _path.default.join(__dirname, "mainScreenPreload.js") }, additionalArguments: ["--enable-node-leakage-in-renderers"] }, icon: _path.default.join(__dirname, "images", "discord.png") }; "linux" === process.platform && (n.frame = !0), settings.get("NO_WINDOWS_BOUND", !1) || applyWindowBoundsToConfig(n); const t = settings.get("GLASSTRON", !0), i = t ? glasstron.BrowserWindow : _electron.BrowserWindow; mainWindow = new i(n), mainWindowId = mainWindow.id, global.mainWindowId = mainWindowId, t && setDefaultBlur(), mainWindow.webContents.session.webRequest.onHeadersReceived(function (e, n) { if (!e.responseHeaders["content-security-policy-report-only"] && !e.responseHeaders["content-security-policy"]) return n({ cancel: !1 }); delete e.responseHeaders["content-security-policy-report-only"], delete e.responseHeaders["content-security-policy"], n({ cancel: !1, responseHeaders: e.responseHeaders }) }), mainWindow.setMenuBarVisibility(!1), settings.get("NO_WINDOWS_BOUND", !1) || (settings.get("IS_MAXIMIZED") && mainWindow.maximize(), settings.get("IS_MINIMIZED") && mainWindow.minimize()), mainWindow.webContents.on("new-window", (e, n, t, i, o) => { e.preventDefault(), t.startsWith("DISCORD_") && checkUrlOriginMatches(n, WEBAPP_ENDPOINT) && "/popout" === getSanitizedPath(n) ? popoutWindows.openOrFocusWindow(e, n, t, o) : (0, _securityUtils.saferShellOpenExternal)(n) }), mainWindow.webContents.on("did-fail-load", (e, n, t, i) => { insideAuthFlow || i === URL_TO_LOAD && -3 !== n && 0 !== n && (lastPageLoadFailed = !0, console.error("[WebContents] did-fail-load", n, t, `retry in ${connectionBackoff.current} ms`), connectionBackoff.fail(() => { console.log("[WebContents] retrying load", URL_TO_LOAD), loadMainPage() })) }), mainWindow.webContents.on("did-finish-load", () => { insideAuthFlow && mainWindow.webContents && checkUrlOriginMatches(mainWindow.webContents.getURL(), WEBAPP_ENDPOINT) && (insideAuthFlow = !1), mainWindowDidFinishLoad = !0, null != mainWindowInitialPath && (webContentsSend("MAIN_WINDOW_PATH", mainWindowInitialPath), mainWindowInitialPath = null), webContentsSend(null != mainWindow && mainWindow.isFocused() ? "MAIN_WINDOW_FOCUS" : "MAIN_WINDOW_BLUR"), lastPageLoadFailed || connectionBackoff.succeed(), events.emit("ready") }), mainWindow.webContents.on("crashed", (e, n) => { if (n) return void _electron.app.quit(); const t = Date.now(); if (t - lastCrashed < 5e3) return console.error("[WebContents] double crashed... RIP =("), void _electron.app.quit(); lastCrashed = t, console.error("[WebContents] crashed... reloading"), launchMainAppWindow(!0) }), mainWindow.webContents.on("will-navigate", (e, n) => { insideAuthFlow || checkUrlOriginMatches(n, WEBAPP_ENDPOINT) || e.preventDefault() }), mainWindow.webContents.on("did-get-redirect-request", (e, n, t) => { checkUrlOriginMatches(n, WEBAPP_ENDPOINT) && checkUrlOriginMatches(t, "https://accounts.google.com/") && (insideAuthFlow = !0) }), mainWindow.webContents.on("context-menu", (e, n) => { webContentsSend("SPELLCHECK_RESULT", n.misspelledWord, n.dictionarySuggestions) }), mainWindow.webContents.on("devtools-opened", () => { webContentsSend("WINDOW_DEVTOOLS_OPENED") }), mainWindow.webContents.on("devtools-closed", () => { webContentsSend("WINDOW_DEVTOOLS_CLOSED") }), mainWindow.on("focus", () => { webContentsSend("MAIN_WINDOW_FOCUS") }), mainWindow.on("blur", () => { webContentsSend("MAIN_WINDOW_BLUR") }), mainWindow.on("page-title-updated", (e, n) => { null !== mainWindow && (e.preventDefault(), n.endsWith("Justicecord") || (n += " - Justicecord"), mainWindow.setTitle(n)) }), mainWindow.on("leave-html-full-screen", () => { mainWindow.setMenuBarVisibility(!1) }), mainWindow.webContents.on("did-navigate-in-page", (e, n) => { let t; try { t = _url.default.parse(n) } catch (e) { return } t && "/login" === t.pathname && mainWindow.webContents.clearHistory() }), mainWindow.on("swipe", (e, n) => { switch (n) { case "left": webContentsSend("NAVIGATE_BACK", "SWIPE"); break; case "right": webContentsSend("NAVIGATE_FORWARD", "SWIPE") } }), mainWindow.on("app-command", (e, n) => { switch (n) { case "browser-backward": webContentsSend("NAVIGATE_BACK", "BROWSER"); break; case "browser-forward": webContentsSend("NAVIGATE_FORWARD", "BROWSER") } }), "win32" === process.platform && setupNotificationScreen(mainWindow), setupSystemTray(), setupAppBadge(), setupAppConfig(), setupPopouts(), "linux" !== process.platform && "win32" !== process.platform || (systemTray.show(), mainWindow.on("close", e => { null !== mainWindow ? (webContentsSend("MAIN_WINDOW_BLUR"), saveWindowConfig(mainWindow), settings.get("MINIMIZE_TO_TRAY", !0) ? (setWindowVisible(!1), e.preventDefault()) : _electron.app.quit()) : popoutWindows.closePopouts() })), loadMainPage() } let updaterState = _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE; function handleModuleUpdateCheckFinished(e, n, t) { if (!e) return updaterState = _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE, void webContentsSend(_Constants.UpdaterEvents.UPDATE_ERROR); webContentsSend(updaterState = 0 === n ? _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE : t ? _Constants.UpdaterEvents.UPDATE_MANUALLY : _Constants.UpdaterEvents.UPDATE_AVAILABLE) } function handleModuleUpdateDownloadProgress(e, n) { mainWindow && mainWindow.setProgressBar(n), webContentsSend(_Constants.UpdaterEvents.MODULE_INSTALL_PROGRESS, e, n) } function handleModuleUpdateDownloadsFinished(e, n) { mainWindow && mainWindow.setProgressBar(-1), updaterState === _Constants.UpdaterEvents.UPDATE_AVAILABLE && (n > 0 ? (updaterState = _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE, webContentsSend(_Constants.UpdaterEvents.UPDATE_ERROR)) : webContentsSend(updaterState = _Constants.UpdaterEvents.UPDATE_DOWNLOADED)) } function handleModuleUpdateInstalledModule(e, n, t, i) { mainWindow && mainWindow.setProgressBar(-1), webContentsSend(_Constants.UpdaterEvents.MODULE_INSTALLED, e, i) } function setUpdaterState(e) { webContentsSend(updaterState = e) } async function checkForUpdatesWithUpdater(e) { if (updaterState === _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE) { setUpdaterState(_Constants.UpdaterEvents.CHECKING_FOR_UPDATES); try { let n = !1; await e.updateToLatest(e => { null != (e.task.HostInstall || e.task.ModuleInstall) && "Complete" === e.state && (n || (n = !0, setUpdaterState(_Constants.UpdaterEvents.UPDATE_AVAILABLE))) }), setUpdaterState(n ? _Constants.UpdaterEvents.UPDATE_DOWNLOADED : _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE) } catch (e) { console.error("Update to latest failed: ", e), updaterState = _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE, webContentsSend(_Constants.UpdaterEvents.UPDATE_FAILED) } } else webContentsSend(updaterState) } function setupUpdaterEventsWithUpdater(e) { _electron.app.on(_Constants.MenuEvents.CHECK_FOR_UPDATES, () => checkForUpdatesWithUpdater()), _ipcMain.default.on(_Constants.UpdaterEvents.CHECK_FOR_UPDATES, () => checkForUpdatesWithUpdater(e)), _ipcMain.default.on(_Constants.UpdaterEvents.QUIT_AND_INSTALL, () => { saveWindowConfig(mainWindow), mainWindow = null; try { legacyModuleUpdater.quitAndInstallUpdates() } catch (e) { _electron.app.relaunch(), _electron.app.quit() } }), _ipcMain.default.on(_Constants.UpdaterEvents.UPDATER_HISTORY_QUERY_AND_TRUNCATE, () => { null != e.queryAndTruncateHistory ? webContentsSend(_Constants.UpdaterEvents.UPDATER_HISTORY_RESPONSE, e.queryAndTruncateHistory()) : webContentsSend(_Constants.UpdaterEvents.UPDATER_HISTORY_RESPONSE, []) }) } function setupLegacyUpdaterEvents() { _electron.app.on(_Constants.MenuEvents.CHECK_FOR_UPDATES, () => legacyModuleUpdater.checkForUpdates()), legacyModuleUpdater.events.on(legacyModuleUpdater.CHECKING_FOR_UPDATES, () => { webContentsSend(updaterState = _Constants.UpdaterEvents.CHECKING_FOR_UPDATES) }), legacyModuleUpdater.supportsEventObjects ? (legacyModuleUpdater.events.on(legacyModuleUpdater.UPDATE_CHECK_FINISHED, ({ succeeded: e, updateCount: n, manualRequired: t }) => { handleModuleUpdateCheckFinished(e, n, t) }), legacyModuleUpdater.events.on(legacyModuleUpdater.DOWNLOADING_MODULE_PROGRESS, ({ name: e, progress: n }) => { handleModuleUpdateDownloadProgress(e, n) }), legacyModuleUpdater.events.on(legacyModuleUpdater.DOWNLOADING_MODULES_FINISHED, ({ succeeded: e, failed: n }) => { handleModuleUpdateDownloadsFinished(e, n) }), legacyModuleUpdater.events.on(legacyModuleUpdater.INSTALLED_MODULE, ({ name: e, current: n, total: t, succeeded: i }) => { handleModuleUpdateInstalledModule(e, n, t, i) })) : (legacyModuleUpdater.events.on(legacyModuleUpdater.UPDATE_CHECK_FINISHED, (e, n, t) => { handleModuleUpdateCheckFinished(e, n, t) }), legacyModuleUpdater.events.on(legacyModuleUpdater.DOWNLOADING_MODULE_PROGRESS, (e, n) => { handleModuleUpdateDownloadProgress(e, n) }), legacyModuleUpdater.events.on(legacyModuleUpdater.DOWNLOADING_MODULES_FINISHED, (e, n) => { handleModuleUpdateDownloadsFinished(e, n) }), legacyModuleUpdater.events.on(legacyModuleUpdater.INSTALLED_MODULE, (e, n, t, i) => { handleModuleUpdateInstalledModule(e, n, t, i) })), _ipcMain.default.on(_Constants.UpdaterEvents.CHECK_FOR_UPDATES, () => { updaterState === _Constants.UpdaterEvents.UPDATE_NOT_AVAILABLE ? legacyModuleUpdater.checkForUpdates() : webContentsSend(updaterState) }), _ipcMain.default.on(_Constants.UpdaterEvents.QUIT_AND_INSTALL, () => { saveWindowConfig(mainWindow), mainWindow = null; try { legacyModuleUpdater.quitAndInstallUpdates() } catch (e) { _electron.app.relaunch(), _electron.app.quit() } }), _ipcMain.default.on(_Constants.UpdaterEvents.MODULE_INSTALL, (e, n) => { legacyModuleUpdater.install(n, !1) }), _ipcMain.default.on(_Constants.UpdaterEvents.MODULE_QUERY, (e, n) => { webContentsSend(_Constants.UpdaterEvents.MODULE_INSTALLED, n, legacyModuleUpdater.isInstalled(n)) }), _ipcMain.default.on(_Constants.UpdaterEvents.UPDATER_HISTORY_QUERY_AND_TRUNCATE, () => { webContentsSend(_Constants.UpdaterEvents.UPDATER_HISTORY_RESPONSE, legacyModuleUpdater.events.history), legacyModuleUpdater.events.history = [] }) } function init() { _electron.app.on("window-all-closed", () => { }), _electron.app.on("before-quit", () => { saveWindowConfig(mainWindow), mainWindow = null, notificationScreen.close() }), _electron.app.on("gpu-process-crashed", (e, n) => { n && _electron.app.quit() }), _electron.app.on("accessibility-support-changed", (e, n) => webContentsSend("ACCESSIBILITY_SUPPORT_CHANGED", n)), _electron.app.on(_Constants.MenuEvents.OPEN_HELP, () => webContentsSend("HELP_OPEN")), _electron.app.on(_Constants.MenuEvents.OPEN_SETTINGS, () => webContentsSend("USER_SETTINGS_OPEN")), _electron.app.on("second-instance", (e, n) => { null != n && n.indexOf("--squirrel-uninstall") > -1 || null != process.argv && process.argv.slice(1).includes("--multi-instance") || null != mainWindow && (setWindowVisible(!0, !1), mainWindow.focus()) }), _ipcMain.default.on("SETTINGS_UPDATE_BACKGROUND_COLOR", (e, n) => { getBackgroundColor() !== n && setBackgroundColor(n) }); const e = null === _updater.default || void 0 === _updater.default ? void 0 : _updater.default.getUpdater(); null != e ? setupUpdaterEventsWithUpdater(e) : setupLegacyUpdaterEvents(), launchMainAppWindow(!1) } function handleOpenUrl(e) { const n = getSanitizedProtocolPath(e); null != n && (mainWindowDidFinishLoad || (mainWindowInitialPath = n), webContentsSend("MAIN_WINDOW_PATH", n)), null != mainWindow && (setWindowVisible(!0, !1), mainWindow.focus()) } function setMainWindowVisible(e) { setWindowVisible(e, !1) }